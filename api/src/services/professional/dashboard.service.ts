import { PrismaClient } from '@prisma/client';\nimport { cache } from '../../cache';\nimport { logger } from '../../utils/logger';\n\nconst prisma = new PrismaClient();\n\nexport interface DashboardConfig {\n  id: string;\n  title: string;\n  description?: string;\n  currentLayoutId: string;\n  layouts: DashboardLayout[];\n  settings: {\n    theme: 'light' | 'dark' | 'auto';\n    autoRefresh: boolean;\n    refreshInterval: number;\n    showGrid: boolean;\n    allowCustomization: boolean;\n    compactMode: boolean;\n  };\n  permissions: {\n    canEdit: boolean;\n    canShare: boolean;\n    canExport: boolean;\n    canCreateLayouts: boolean;\n  };\n}\n\nexport interface DashboardLayout {\n  id: string;\n  name: string;\n  description?: string;\n  isDefault?: boolean;\n  widgets: WidgetConfig[];\n  gridConfig: {\n    cols: number;\n    rowHeight: number;\n    margin: [number, number];\n    containerPadding: [number, number];\n  };\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface WidgetConfig {\n  id: string;\n  type: string;\n  title: string;\n  description?: string;\n  size: 'small' | 'medium' | 'large' | 'extra-large';\n  position: {\n    x: number;\n    y: number;\n    w: number;\n    h: number;\n  };\n  config?: {\n    showHeader?: boolean;\n    showFooter?: boolean;\n    allowResize?: boolean;\n    allowMove?: boolean;\n    allowRemove?: boolean;\n  };\n  permissions?: {\n    view: boolean;\n    edit: boolean;\n    delete: boolean;\n  };\n}\n\nclass DashboardService {\n  private getCacheKey(tenantId: string, userId: string, suffix: string = '') {\n    return `dashboard:${tenantId}:${userId}${suffix ? ':' + suffix : ''}`;\n  }\n\n  async getDashboardConfig(tenantId: string, userId: string): Promise<DashboardConfig> {\n    const cacheKey = this.getCacheKey(tenantId, userId, 'config');\n    \n    try {\n      // Try to get from cache first\n      const cached = await cache.get(cacheKey);\n      if (cached) {\n        return JSON.parse(cached);\n      }\n\n      // Fetch from database\n      const config = await this.fetchDashboardConfigFromDB(tenantId, userId);\n      \n      // Cache for 5 minutes\n      await cache.setex(cacheKey, 300, JSON.stringify(config));\n      \n      return config;\n    } catch (error) {\n      logger.error('Error fetching dashboard config:', error);\n      throw error;\n    }\n  }\n\n  private async fetchDashboardConfigFromDB(tenantId: string, userId: string): Promise<DashboardConfig> {\n    // This would typically fetch from a dashboard_configs table\n    // For now, return a default configuration\n    return {\n      id: `dashboard-${tenantId}-${userId}`,\n      title: 'Executive Dashboard',\n      description: 'Real-time insights and key performance indicators',\n      currentLayoutId: 'default-layout',\n      layouts: [\n        {\n          id: 'default-layout',\n          name: 'Default Layout',\n          description: 'Standard executive dashboard layout',\n          isDefault: true,\n          widgets: [],\n          gridConfig: {\n            cols: 12,\n            rowHeight: 80,\n            margin: [16, 16],\n            containerPadding: [16, 16],\n          },\n          createdAt: new Date(),\n          updatedAt: new Date(),\n        },\n      ],\n      settings: {\n        theme: 'light',\n        autoRefresh: true,\n        refreshInterval: 30,\n        showGrid: false,\n        allowCustomization: true,\n        compactMode: false,\n      },\n      permissions: {\n        canEdit: true,\n        canShare: true,\n        canExport: true,\n        canCreateLayouts: true,\n      },\n    };\n  }\n\n  async updateDashboardConfig(\n    tenantId: string,\n    userId: string,\n    updates: Partial<DashboardConfig>\n  ): Promise<DashboardConfig> {\n    try {\n      // Get current config\n      const currentConfig = await this.getDashboardConfig(tenantId, userId);\n      \n      // Merge updates\n      const updatedConfig = {\n        ...currentConfig,\n        ...updates,\n        settings: {\n          ...currentConfig.settings,\n          ...updates.settings,\n        },\n      };\n\n      // Save to database (implementation would go here)\n      // await this.saveDashboardConfigToDB(tenantId, userId, updatedConfig);\n\n      // Update cache\n      const cacheKey = this.getCacheKey(tenantId, userId, 'config');\n      await cache.setex(cacheKey, 300, JSON.stringify(updatedConfig));\n\n      logger.info(`Dashboard config updated for tenant ${tenantId}, user ${userId}`);\n      return updatedConfig;\n    } catch (error) {\n      logger.error('Error updating dashboard config:', error);\n      throw error;\n    }\n  }\n\n  async getDashboardLayouts(tenantId: string, userId: string): Promise<DashboardLayout[]> {\n    try {\n      const config = await this.getDashboardConfig(tenantId, userId);\n      return config.layouts;\n    } catch (error) {\n      logger.error('Error fetching dashboard layouts:', error);\n      throw error;\n    }\n  }\n\n  async createDashboardLayout(\n    tenantId: string,\n    userId: string,\n    layoutData: Omit<DashboardLayout, 'id' | 'createdAt' | 'updatedAt'>\n  ): Promise<DashboardLayout> {\n    try {\n      const newLayout: DashboardLayout = {\n        ...layoutData,\n        id: `layout-${Date.now()}`,\n        createdAt: new Date(),\n        updatedAt: new Date(),\n      };\n\n      // Get current config and add new layout\n      const config = await this.getDashboardConfig(tenantId, userId);\n      config.layouts.push(newLayout);\n\n      // Update config\n      await this.updateDashboardConfig(tenantId, userId, config);\n\n      logger.info(`Dashboard layout created for tenant ${tenantId}, user ${userId}`);\n      return newLayout;\n    } catch (error) {\n      logger.error('Error creating dashboard layout:', error);\n      throw error;\n    }\n  }\n\n  async updateDashboardLayout(\n    tenantId: string,\n    userId: string,\n    layoutId: string,\n    updates: Partial<DashboardLayout>\n  ): Promise<DashboardLayout> {\n    try {\n      const config = await this.getDashboardConfig(tenantId, userId);\n      const layoutIndex = config.layouts.findIndex(layout => layout.id === layoutId);\n      \n      if (layoutIndex === -1) {\n        throw new Error('Layout not found');\n      }\n\n      // Update layout\n      config.layouts[layoutIndex] = {\n        ...config.layouts[layoutIndex],\n        ...updates,\n        updatedAt: new Date(),\n      };\n\n      // Update config\n      await this.updateDashboardConfig(tenantId, userId, config);\n\n      logger.info(`Dashboard layout ${layoutId} updated for tenant ${tenantId}, user ${userId}`);\n      return config.layouts[layoutIndex];\n    } catch (error) {\n      logger.error('Error updating dashboard layout:', error);\n      throw error;\n    }\n  }\n\n  async deleteDashboardLayout(\n    tenantId: string,\n    userId: string,\n    layoutId: string\n  ): Promise<void> {\n    try {\n      const config = await this.getDashboardConfig(tenantId, userId);\n      const layoutIndex = config.layouts.findIndex(layout => layout.id === layoutId);\n      \n      if (layoutIndex === -1) {\n        throw new Error('Layout not found');\n      }\n\n      // Don't allow deletion of default layout\n      if (config.layouts[layoutIndex].isDefault) {\n        throw new Error('Cannot delete default layout');\n      }\n\n      // Remove layout\n      config.layouts.splice(layoutIndex, 1);\n\n      // If this was the current layout, switch to default\n      if (config.currentLayoutId === layoutId) {\n        const defaultLayout = config.layouts.find(layout => layout.isDefault);\n        config.currentLayoutId = defaultLayout?.id || config.layouts[0]?.id;\n      }\n\n      // Update config\n      await this.updateDashboardConfig(tenantId, userId, config);\n\n      logger.info(`Dashboard layout ${layoutId} deleted for tenant ${tenantId}, user ${userId}`);\n    } catch (error) {\n      logger.error('Error deleting dashboard layout:', error);\n      throw error;\n    }\n  }\n\n  async getDashboardData(\n    tenantId: string,\n    widgetIds?: string[],\n    timeRange: string = '30d'\n  ): Promise<Record<string, any>> {\n    try {\n      // This would fetch real data from various sources\n      // For now, return mock data\n      const mockData = {\n        'total-users': {\n          title: 'Total Users',\n          value: '12,543',\n          change: '+12.5%',\n          trend: 'up',\n        },\n        'revenue': {\n          title: 'Revenue',\n          value: '$45,231',\n          change: '+8.2%',\n          trend: 'up',\n        },\n        'conversion-rate': {\n          title: 'Conversion Rate',\n          value: '3.24%',\n          change: '-0.5%',\n          trend: 'down',\n        },\n        'compliance-score': {\n          title: 'Compliance Score',\n          value: '94%',\n          change: '+2.1%',\n          trend: 'up',\n        },\n      };\n\n      // Filter by widget IDs if provided\n      if (widgetIds) {\n        const filteredData: Record<string, any> = {};\n        widgetIds.forEach(id => {\n          if (mockData[id as keyof typeof mockData]) {\n            filteredData[id] = mockData[id as keyof typeof mockData];\n          }\n        });\n        return filteredData;\n      }\n\n      return mockData;\n    } catch (error) {\n      logger.error('Error fetching dashboard data:', error);\n      throw error;\n    }\n  }\n}\n\nexport const dashboardService = new DashboardService();"